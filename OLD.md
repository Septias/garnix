=== Free Variables
Because of Nix's lazy evaluation, well-formed programs can specify arbitrary unbound variables, which are later looked up from the context as if they were explicitly bound. This silently adds implicit function arguments to the language, which consequently adds functions that change their signature based on the context. While this is a neat trick for programmers, implicit arguments are tricky from a type inference perspective. A function definition, say `let f = a: b: a + c in t` containing a free variable $c$, could be used in different contexts that relate `c` to variables with different types. If `c` is bound to a value of type bool, the function type would be $f: "bool" -> b -> "bool"$ and if it was bound to a string $f: "string" -> b -> "string"$. To salvage this flexibility, the context would have to be checked and all function types that refer to a variable would have to be recomputed when new variables are bound. While this is, in theory, possible, it is out of the scope of this paper.
Even though free variables are, in principle, allowed, there is room for discussion about their usefulness in practice and whether they belong to a language that boasts itself with perfect reproducibility. Allowing functions to depend on the context obfuscates program flow and adds many implicit assumptions that are hard to follow for humans and a source of error. This is probably also why the import function errors when the surrounding context fills free variables in the imported expression.