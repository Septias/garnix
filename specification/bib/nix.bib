@INPROCEEDINGS{memory_to_software,
  author={Dolstra, E. and Visser, E. and de Jonge, M.},
  booktitle={Proceedings. 26th International Conference on Software Engineering}, 
  title={Imposing a memory management discipline on software deployment}, 
  year={2004},
  volume={},
  number={},
  pages={583-592},
  keywords={Memory management;Hazards;Computer languages;Packaging;Interference;Linux;Software maintenance;Independent component analysis;Concurrent computing;Application software},
  doi={10.1109/ICSE.2004.1317480}
}
@inproceedings{dolstra_phd,
  title={The purely functional software deployment model},
  author={Eelco Dolstra},
  year={2006},
  url={https://api.semanticscholar.org/CorpusID:8511820}
}

@inproceedings{nixos_short,
author = {Dolstra, Eelco and L\"{o}h, Andres},
title = {NixOS: a purely functional Linux distribution},
year = {2008},
isbn = {9781595939197},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1411204.1411255},
doi = {10.1145/1411204.1411255},
abstract = {Existing package and system configuration management tools suffer from an imperative model, where system administration actions such as upgrading packages or changes to system configuration files are stateful: they destructively update the state of the system. This leads to many problems, such as the inability to roll back changes easily, to run multiple versions of a package side-by-side, to reproduce a configuration deterministically on another machine, or to reliably upgrade a system. In this paper we show that we can overcome these problems by moving to a purely functional system configuration model. This means that all static parts of a system (such as software packages, configuration files and system startup scripts) are built by pure functions and are immutable, stored in a way analogously to a heap in a purely function language. We have implemented this model in NixOS, a non-trivial Linux distribution that uses the Nix package manager to build the entire system configuration from a purely functional specification.},
booktitle = {Proceedings of the 13th ACM SIGPLAN International Conference on Functional Programming},
pages = {367–378},
numpages = {12},
keywords = {NixOS, nix, package management, purely functional deployment model, purely functional language, software deployment, system configuration management},
location = {Victoria, BC, Canada},
series = {ICFP '08}
}

@article{max_lazy,
title = {Maximal Laziness: An Efficient Interpretation Technique for Purely Functional DSLs},
journal = {Electronic Notes in Theoretical Computer Science},
volume = {238},
number = {5},
pages = {81-99},
year = {2009},
note = {Proceedings of the 8th Workshop on Language Descriptions, Tools and Applications (LDTA 2008)},
issn = {1571-0661},
doi = {https://doi.org/10.1016/j.entcs.2009.09.042},
url = {https://www.sciencedirect.com/science/article/pii/S157106610900396X},
author = {Eelco Dolstra},
keywords = {Lazy functional language, maximallaziness, maximal sharing},
abstract = {In lazy functional languages, any variable is evaluated at most once. This paper proposes the notion of maximal laziness, in which syntactically equal terms are evaluated at most once: if two terms e1 and e2 arising during the evaluation of a program have the same abstract syntax representation, then only one will be evaluated, while the other will reuse the former's evaluation result. Maximal laziness can be implemented easily in interpreters for purely functional languages based on term rewriting systems that have the property of maximal sharing — if two terms are equal, they have the same address. It makes it easier to write interpreters, as techniques such as closure updating, which would otherwise be required for efficiency, are not needed. Instead, a straight-forward translation of call-by-name semantic rules yields a call-by-need interpreter, reducing the gap between the language specification and its implementation. Moreover, maximal laziness obviates the need for optimisations such as memoisation and let-floating.}
}


@article{nixos_long,
title={NixOS: A purely functional Linux distribution},
volume={20},
DOI={10.1017/S0956796810000195},
number={5–6},
journal={Journal of Functional Programming},
author={DOLSTRA, EELCO and LÖH, ANDRES and PIERRON, NICOLAS},
year={2010},
pages={577–615}
}


@Inbook{introducing_linux_distros,
author="Dieguez Castro, Jose",
title="Introducing Linux Distros",
bookTitle="Introducing Linux Distros",
year="2016",
publisher="Apress",
address="Berkeley, CA",
pages="301--327",
abstract="Thus Nix was created as part of academic research and NixOS was created as a proof of concept that Nix could be used to manage a whole Linux distro. Dolstra also would develop other tools like Hydra, which is a Nix-based continuous integration tool, and NixOps, which is a tool for provisioning and deploying NixOS machines.",
isbn="978-1-4842-1392-6",
doi="10.1007/978-1-4842-1392-6_14",
url="https://doi.org/10.1007/978-1-4842-1392-6_14"
}

@article{verified,
author = {Broekhoff, Rutger and Krebbers, Robbert},
title = {Verified Interpreters for Dynamic Languages with Applications to the Nix Expression Language},
year = {2025},
issue_date = {August 2025},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {9},
number = {ICFP},
url = {https://doi.org/10.1145/3747537},
doi = {10.1145/3747537},
abstract = {To study the semantics of a programming language, it is useful to consider different specification forms—e.g., a substitution-based small-step operational semantics and an environment-based interpreter—because they have mutually exclusive benefits. Developing these specifications and proving correspondences is challenging for ‘dynamic’/‘scripting’ languages such as JavaScript, PHP and Bash. We study this challenge in the context of the Nix expression language, a dynamic language used in the eponymous package manager and operating system. Nix is a Turing-complete, untyped functional language designed for the manipulation of JSON-style attribute sets, with tricky features such as overloaded use of variables for lambda bindings and attribute members, subtle shadowing rules, a mixture of evaluation strategies, and tricky mechanisms for recursion.We show that our techniques are applicable beyond Nix by starting from the call-by-name lambda calculus, which we extend to a core lambda calculus with dynamically computed variable names and dynamic binder names, and finally to Nix. Our key novelty is the use of a form of deferred substitutions, which enables us to give a concise substitution-based semantics for dynamic variable binding. We develop corresponding environment-based interpreters, which we prove to be sound and complete (for terminating, faulty and diverging programs) w.r.t. our operational semantics based on deferred substitutions.We mechanize all our results in the Rocq prover and showcase a new feature of the Rocq-std++ library for representing syntax with maps in recursive positions. We use Rocq’s extraction mechanism to turn our Nix interpreter into executable OCaml code, which we apply to the official Nix language tests.   Altogether this gives rise to the most comprehensive formal semantics for the Nix expression language to date.},
journal = {Proc. ACM Program. Lang.},
month = aug,
articleno = {268},
numpages = {30},
keywords = {Interpreters, Nix, Rocq, lambda calculus, substitution}
}
