@article{algebraic_subtyping,
  title={Algebraic Subtyping},
  author={Dolan, S.},
  isbn={9781780174150},
  series={BCS/CPHC distinguished dissertation award series},
  url={https://books.google.co.jp/books?id=cBJdswEACAAJ},
  year={2017},
  publisher={BCS Learning \& Development Limited}
}

/*
- Subtyping lattice
- [[Subtyping]] is acting on this lattice and inherits better properties
- [[Biunification]] as parallel to unification in ML
- [[Open world]] system to be extensible
- [[Type scheme]]s and [[Typing scheme]]s
- Uses [[Polar types]] to distinguish flow in a program
	- Unions can only be used in output positions and intersections in input
- Type [[automatons]] to simplify types

> Find the simplest algebra of types, and some syntax for them 

So, we conclude that the extensible way to define a subtyping system is to define types as a coproduct of distributive lattices. 

*/

@article{mlsub,
author = {Dolan, Stephen and Mycroft, Alan},
title = {Polymorphism, subtyping, and type inference in MLsub},
year = {2017},
issue_date = {January 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/3093333.3009882},
doi = {10.1145/3093333.3009882},
abstract = {We present a type system combining subtyping and ML-style parametric polymorphism. Unlike previous work, our system supports type inference and has compact principal types. We demonstrate this system in the minimal language MLsub, which types a strict superset of core ML programs. This is made possible by keeping a strict separation between the types used to describe inputs and those used to describe outputs, and extending the classical unification algorithm to handle subtyping constraints between these input and output types. Principal types are kept compact by type simplification, which exploits deep connections between subtyping and the algebra of regular languages. An implementation is available online.},
journal = {SIGPLAN Not.},
month = {jan},
pages = {60–72},
numpages = {13},
keywords = {Type Inference, Subtyping, Polymorphism, Algebra}
}

  
@manual{nix-language-2-28,
  title        = {Nix Language — Nix 2.28 Reference Manual},
  organization = {Nix.dev},
  year         = {2025},
  url          = {https://nix.dev/manual/nix/2.28/language/index.html},
  note         = {Accessed: 2026-01-11},
}


@article{verified,
author = {Broekhoff, Rutger and Krebbers, Robbert},
title = {Verified Interpreters for Dynamic Languages with Applications to the Nix Expression Language},
year = {2025},
issue_date = {August 2025},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {9},
number = {ICFP},
url = {https://doi.org/10.1145/3747537},
doi = {10.1145/3747537},
abstract = {To study the semantics of a programming language, it is useful to consider different specification forms—e.g., a substitution-based small-step operational semantics and an environment-based interpreter—because they have mutually exclusive benefits. Developing these specifications and proving correspondences is challenging for ‘dynamic’/‘scripting’ languages such as JavaScript, PHP and Bash. We study this challenge in the context of the Nix expression language, a dynamic language used in the eponymous package manager and operating system. Nix is a Turing-complete, untyped functional language designed for the manipulation of JSON-style attribute sets, with tricky features such as overloaded use of variables for lambda bindings and attribute members, subtle shadowing rules, a mixture of evaluation strategies, and tricky mechanisms for recursion.We show that our techniques are applicable beyond Nix by starting from the call-by-name lambda calculus, which we extend to a core lambda calculus with dynamically computed variable names and dynamic binder names, and finally to Nix. Our key novelty is the use of a form of deferred substitutions, which enables us to give a concise substitution-based semantics for dynamic variable binding. We develop corresponding environment-based interpreters, which we prove to be sound and complete (for terminating, faulty and diverging programs) w.r.t. our operational semantics based on deferred substitutions.We mechanize all our results in the Rocq prover and showcase a new feature of the Rocq-std++ library for representing syntax with maps in recursive positions. We use Rocq’s extraction mechanism to turn our Nix interpreter into executable OCaml code, which we apply to the official Nix language tests.   Altogether this gives rise to the most comprehensive formal semantics for the Nix expression language to date.},
journal = {Proc. ACM Program. Lang.},
month = aug,
articleno = {268},
numpages = {30},
keywords = {Interpreters, Nix, Rocq, lambda calculus, substitution}
}


@BachelorThesis{simplenix,
  author  = {Sebastian Klähn},
  title   = {SimpleNix: Type Inference for Nix},
  school  = {Universität Freiburg},
  year    = {2023},
  type    = {Bachelor's Thesis},
  url     = {https://github.com/Septias/bachelor-thesis/blob/main/main.pdf}
}
