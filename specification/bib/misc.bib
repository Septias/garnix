@article{algebraic_subtyping,
  title={Algebraic Subtyping},
  author={Dolan, S.},
  isbn={9781780174150},
  series={BCS/CPHC distinguished dissertation award series},
  url={https://books.google.co.jp/books?id=cBJdswEACAAJ},
  year={2017},
  publisher={BCS Learning \& Development Limited}
}

/*
- Subtyping lattice
- [[Subtyping]] is acting on this lattice and inherits better properties
- [[Biunification]] as parallel to unification in ML
- [[Open world]] system to be extensible
- [[Type scheme]]s and [[Typing scheme]]s
- Uses [[Polar types]] to distinguish flow in a program
	- Unions can only be used in output positions and intersections in input
- Type [[automatons]] to simplify types

> Find the simplest algebra of types, and some syntax for them 

So, we conclude that the extensible way to define a subtyping system is to define types as a coproduct of distributive lattices. 

*/

@article{mlsub,
author = {Dolan, Stephen and Mycroft, Alan},
title = {Polymorphism, subtyping, and type inference in MLsub},
year = {2017},
issue_date = {January 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/3093333.3009882},
doi = {10.1145/3093333.3009882},
abstract = {We present a type system combining subtyping and ML-style parametric polymorphism. Unlike previous work, our system supports type inference and has compact principal types. We demonstrate this system in the minimal language MLsub, which types a strict superset of core ML programs. This is made possible by keeping a strict separation between the types used to describe inputs and those used to describe outputs, and extending the classical unification algorithm to handle subtyping constraints between these input and output types. Principal types are kept compact by type simplification, which exploits deep connections between subtyping and the algebra of regular languages. An implementation is available online.},
journal = {SIGPLAN Not.},
month = {jan},
pages = {60–72},
numpages = {13},
keywords = {Type Inference, Subtyping, Polymorphism, Algebra}
}

  
@article{10.1145/3607838,
author = {Castagna, Giuseppe},
title = {Typing Records, Maps, and Structs},
year = {2023},
issue_date = {August 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {ICFP},
url = {https://doi.org/10.1145/3607838},
doi = {10.1145/3607838},
abstract = {Records are finite functions from keys to values. In this work we focus on two main distinct usages of records: structs and maps. The former associate different keys to values of different types, they are accessed by providing nominal keys, and trying to access a non-existent key yields an error. The latter associate all keys to values of the same type, they are accessed by providing expressions that compute a key, and trying to access a non-existent key usually yields some default value such as Null or nil. Here, we propose a type theory that covers both kinds of usage, where record types may associate to different types either single keys (as for structs) or sets of keys (as for maps) and where the same record expression can be accessed and used both in the struct-like style and in the map-like style we just described. Since we target dynamically-typed languages our type theory includes union and intersection types, characterized by a subtyping relation. We define the subtyping relation for our record types via a semantic interpretation and derive the decomposition rules to decide it, define a backtracking-free subtyping algorithm that we prove to be correct, and provide a canonical representation for record types that is used to define various type operators needed to type record operations such as selection, concatenation, and field deletion.},
journal = {Proc. ACM Program. Lang.},
month = aug,
articleno = {196},
numpages = {44},
keywords = {dictionaries, dynamic languages, intersection types, subtyping, union types}
}


/*

They also identify static typing of record concatenation as a particularly difficult problem because of label conflicts.

types record concatenation by solving subtyping constraint systems in which the type “Abs” for undefined fields is separated from all other types,

*/
