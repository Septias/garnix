@article{algebraic_subtyping,
  title={Algebraic Subtyping},
  author={Dolan, S.},
  isbn={9781780174150},
  series={BCS/CPHC distinguished dissertation award series},
  url={https://books.google.co.jp/books?id=cBJdswEACAAJ},
  year={2017},
  publisher={BCS Learning \& Development Limited}
}

/*
- Subtyping lattice
- [[Subtyping]] is acting on this lattice and inherits better properties
- [[Biunification]] as parallel to unification in ML
- [[Open world]] system to be extensible
- [[Type scheme]]s and [[Typing scheme]]s
- Uses [[Polar types]] to distinguish flow in a program
	- Unions can only be used in output positions and intersections in input
- Type [[automatons]] to simplify types

> Find the simplest algebra of types, and some syntax for them 

So, we conclude that the extensible way to define a subtyping system is to define types as a coproduct of distributive lattices. 

*/

@article{mlsub,
author = {Dolan, Stephen and Mycroft, Alan},
title = {Polymorphism, subtyping, and type inference in MLsub},
year = {2017},
issue_date = {January 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/3093333.3009882},
doi = {10.1145/3093333.3009882},
abstract = {We present a type system combining subtyping and ML-style parametric polymorphism. Unlike previous work, our system supports type inference and has compact principal types. We demonstrate this system in the minimal language MLsub, which types a strict superset of core ML programs. This is made possible by keeping a strict separation between the types used to describe inputs and those used to describe outputs, and extending the classical unification algorithm to handle subtyping constraints between these input and output types. Principal types are kept compact by type simplification, which exploits deep connections between subtyping and the algebra of regular languages. An implementation is available online.},
journal = {SIGPLAN Not.},
month = {jan},
pages = {60–72},
numpages = {13},
keywords = {Type Inference, Subtyping, Polymorphism, Algebra}
}

  
@manual{nix-language-2-28,
  title        = {Nix Language — Nix 2.28 Reference Manual},
  organization = {Nix.dev},
  year         = {2025},
  url          = {https://nix.dev/manual/nix/2.28/language/index.html},
  note         = {Accessed: 2026-01-11},
}


@article{verified,
author = {Broekhoff, Rutger and Krebbers, Robbert},
title = {Verified Interpreters for Dynamic Languages with Applications to the Nix Expression Language},
year = {2025},
issue_date = {August 2025},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {9},
number = {ICFP},
url = {https://doi.org/10.1145/3747537},
doi = {10.1145/3747537},
abstract = {To study the semantics of a programming language, it is useful to consider different specification forms—e.g., a substitution-based small-step operational semantics and an environment-based interpreter—because they have mutually exclusive benefits. Developing these specifications and proving correspondences is challenging for ‘dynamic’/‘scripting’ languages such as JavaScript, PHP and Bash. We study this challenge in the context of the Nix expression language, a dynamic language used in the eponymous package manager and operating system. Nix is a Turing-complete, untyped functional language designed for the manipulation of JSON-style attribute sets, with tricky features such as overloaded use of variables for lambda bindings and attribute members, subtle shadowing rules, a mixture of evaluation strategies, and tricky mechanisms for recursion.We show that our techniques are applicable beyond Nix by starting from the call-by-name lambda calculus, which we extend to a core lambda calculus with dynamically computed variable names and dynamic binder names, and finally to Nix. Our key novelty is the use of a form of deferred substitutions, which enables us to give a concise substitution-based semantics for dynamic variable binding. We develop corresponding environment-based interpreters, which we prove to be sound and complete (for terminating, faulty and diverging programs) w.r.t. our operational semantics based on deferred substitutions.We mechanize all our results in the Rocq prover and showcase a new feature of the Rocq-std++ library for representing syntax with maps in recursive positions. We use Rocq’s extraction mechanism to turn our Nix interpreter into executable OCaml code, which we apply to the official Nix language tests.   Altogether this gives rise to the most comprehensive formal semantics for the Nix expression language to date.},
journal = {Proc. ACM Program. Lang.},
month = aug,
articleno = {268},
numpages = {30},
keywords = {Interpreters, Nix, Rocq, lambda calculus, substitution}
}


/*
This example thus shows that the basic property of closedness—which arguably every program should satisfy—is not statically checkable in dynamic languages

Similarly, one cannot statically check if a variable is shadowed: 

*/

@BachelorThesis{simplenix,
  author  = {Sebastian Klähn},
  title   = {SimpleNix: Type Inference for Nix},
  school  = {Universität Freiburg},
  year    = {2023},
  type    = {Bachelor's Thesis},
  url     = {https://github.com/Septias/bachelor-thesis/blob/main/main.pdf}
}


@misc{typescript,
  title        = {TypeScript},
  author       = {{Microsoft}},
  year         = {2012},
  howpublished = {\url{https://www.typescriptlang.org/}},
  note         = {Accessed: 2026-01-14}
}


@misc{flow,
  title        = {Flow: A Static Type Checker for JavaScript},
  author       = {{Meta Platforms, Inc.}},
  year         = {2014},
  howpublished = {\url{https://flow.org/}},
  note         = {Accessed: 2026-01-14}
}

@inproceedings{typed_racket,
author = {Tobin-Hochstadt, Sam and Felleisen, Matthias},
title = {The design and implementation of typed scheme},
year = {2008},
isbn = {9781595936899},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1328438.1328486},
doi = {10.1145/1328438.1328486},
abstract = {When scripts in untyped languages grow into large programs, maintaining them becomes difficult. A lack of types in typical scripting languages means that programmers must (re)discover critical pieces of design information every time they wish to change a program. This analysis step both slows down the maintenance process and may even introduce mistakes due to the violation of undiscovered invariants.This paper presents Typed Scheme, an explicitly typed extension of an untyped scripting language. Its type system is based on the novel notion of occurrence typing, which we formalize and mechanically prove sound. The implementation of Typed Scheme additionally borrows elements from a range of approaches, including recursive types, true unions and subtyping, plus polymorphism combined with a modicum of local inference. Initial experiments with the implementation suggest that Typed Scheme naturally accommodates the programming style of the underlying scripting language, at least for the first few thousand lines of ported code.},
booktitle = {Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {395–406},
numpages = {12},
keywords = {type systems, scheme},
location = {San Francisco, California, USA},
series = {POPL '08}
}

@article{revisiting_occurrence,
   title={Revisiting occurrence typing},
   volume={217},
   ISSN={0167-6423},
   url={http://dx.doi.org/10.1016/j.scico.2022.102781},
   DOI={10.1016/j.scico.2022.102781},
   journal={Science of Computer Programming},
   publisher={Elsevier BV},
   author={Castagna, Giuseppe and Lanvin, Victor and Laurent, Mickaël and Nguyen, Kim},
   year={2022},
   month=may, pages={102781}
}

@article{quicksub,
author = {Zhou, Litao and Oliveira, Bruno C. d. S.},
title = {QuickSub: Efficient Iso-Recursive Subtyping},
year = {2025},
issue_date = {January 2025},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {9},
number = {POPL},
url = {https://doi.org/10.1145/3704869},
doi = {10.1145/3704869},
abstract = {Many programming languages need to check whether two recursive types are in a subtyping relation. Traditionally recursive types are modelled in two different ways: equi- or iso- recursive types. While efficient algorithms for subtyping equi-recursive types are well studied for simple type systems, efficient algorithms for iso-recursive subtyping remain understudied.   In this paper we present QuickSub: an efficient and simple to implement algorithm for iso-recursive subtyping. QuickSub has the same expressive power as the well-known iso-recursive Amber rules. The worst case complexity of QuickSub is O(nm), where m is the size of the type and n is the number of recursive binders. However, in practice, the algorithm is nearly linear with the worst case being hard to reach. Consequently, in many common cases, QuickSub can be several times faster than alternative algorithms. We validate the efficiency of QuickSub with an empirical evaluation comparing it to existing equi-recursive and iso-recursive subtyping algorithms. We prove the correctness of the algorithm and formalize a simple calculus with recursive subtyping and records. For this calculus we also show how type soundness can be proved using QuickSub. All the results have been formalized and proved in the Coq proof assistant.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {33},
numpages = {32},
keywords = {Algorithm, Recursive types, Subtyping}
}
