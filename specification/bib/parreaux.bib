@article{simplesub,
author = {Parreaux, Lionel},
title = {The simple essence of algebraic subtyping: principal type inference with subtyping made easy (functional pearl)},
year = {2020},
issue_date = {August 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {ICFP},
url = {https://doi.org/10.1145/3409006},
doi = {10.1145/3409006},
abstract = {MLsub extends traditional Hindley-Milner type inference with subtyping while preserving compact principal types, an exciting new development. However, its specification in terms of biunification is difficult to understand, relying on the new concepts of bisubstitution and polar types, and making use of advanced notions from abstract algebra. In this paper, we show that these are in fact not essential to understanding the mechanisms at play in MLsub. We propose an alternative algorithm called Simple-sub, which can be implemented efficiently in under 500 lines of code (including parsing, simplification, and pretty-printing), looks more familiar, and is easier to understand.  We present an experimental evaluation of Simple-sub against MLsub on a million randomly-generated well-scoped expressions, showing that the two systems agree. The mutable automaton-based implementation of MLsub is quite far from its algebraic specification, leaving a lot of space for errors; in fact, our evaluation uncovered several bugs in it. We sketch more straightforward soundness and completeness arguments for Simple-sub, based on a syntactic specification of the type system.  This paper is meant to be light in formalism, rich in insights, and easy to consume for prospective designers of new type systems and programming languages. In particular, no abstract algebra is inflicted on readers.},
journal = {Proc. ACM Program. Lang.},
month = {aug},
articleno = {124},
numpages = {28},
keywords = {type inference, subtyping, principal types}
}
/*
- Translates algberaic subtyping to syntactic version
- Constraints are broken down and finally installed on _mutable type variables_
- Introduces levels for different grades of polymorphism (let vs. lambda)
- Introduces extrusion to solve level-problems
*/


@article{mlstruct,
author = {Parreaux, Lionel and Chau, Chun Yin},
title = {MLstruct: principal type inference in a Boolean algebra of structural types},
year = {2022},
issue_date = {October 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {OOPSLA2},
url = {https://doi.org/10.1145/3563304},
doi = {10.1145/3563304},
abstract = {Intersection and union types are becoming more popular by the day, entering the mainstream in programming languages like TypeScript and Scala 3. Yet, no language so far has managed to combine these powerful types with principal polymorphic type inference. We present a solution to this problem in MLstruct, a language with subtyped records, equirecursive types, first-class unions and intersections, class-based instance matching, and ML-style principal type inference. While MLstruct is mostly structurally typed, it contains a healthy sprinkle of nominality for classes, which gives it desirable semantics, enabling the expression of a powerful form of extensible variants that does not need row variables. Technically, we define the constructs of our language using conjunction, disjunction, and negation connectives, making sure they form a Boolean algebra, and we show that the addition of a few nonstandard but sound subtyping rules gives us enough structure to derive a sound and complete type inference algorithm. With this work, we hope to foster the development of better type inference for present and future programming languages with expressive subtyping systems.},
journal = {Proc. ACM Program. Lang.},
month = oct,
articleno = {141},
numpages = {30},
keywords = {union and intersection types, structural typing, principal type inference}
}

/*

Odersky et al. [1999] gave them a unified account by proposing a general framework called HM(X), where the ‘X’ stands for a constraint solver to plug into their generic system. While these approaches often claimed a form of principal type inference (also called minimality29), the constrained types they inferred were often large and unwieldy.

*/


@article{superF,
author = {Parreaux, Lionel and Boruch-Gruszecki, Aleksander and Fan, Andong and Chau, Chun Yin},
title = {When Subtyping Constraints Liberate: A Novel Type Inference Approach for First-Class Polymorphism},
year = {2024},
issue_date = {January 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {POPL},
url = {https://doi.org/10.1145/3632890},
doi = {10.1145/3632890},
abstract = {Type inference in the presence of first-class or “impredicative” second-order polymorphism \`{a} la System F has been an active research area for several decades, with original works dating back to the end of the 80s. Yet, until now many basic problems remain open, such as how to type check expressions like (λx.(x  123, x  True)) id reliably. We show that a type inference approach based on multi-bounded polymorphism, a form of implicit polymorphic subtyping with multiple lower and upper bounds, can help us resolve most of these problems in a uniquely simple and regular way. We define F≤, a declarative type system derived from the existing theory of implicit coercions by Cretin and R\'{e}my (LICS 2014), and we introduce SuperF, a novel algorithm to infer polymorphic multi-bounded F≤ types while checking user type annotations written in the syntax of System F. We use a recursion-avoiding heuristic to guarantee termination of type inference at the cost of rejecting some valid programs, which thankfully rarely triggers in practice. We show that SuperF is vastly more powerful than all first-class-polymorphic type inference systems proposed so far, significantly advancing the state of the art in type inference for general-purpose programming languages.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {48},
numpages = {33},
keywords = {type inference, first-class polymorphism, subtyping, constraint solving}
}

/*

We saw that intersections were better at expressing requirements on the types of inputs, since making these requirements as weak as possible conversely strengthens the overall typ
*/


@article{invalml,
author = {Gao, Cunyuan and Parreaux, Lionel},
title = {A Lightweight Type-and-Effect System for Invalidation Safety: Tracking Permanent and Temporary Invalidation with Constraint-Based Subtype Inference},
year = {2025},
issue_date = {October 2025},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {9},
number = {OOPSLA2},
url = {https://doi.org/10.1145/3763144},
doi = {10.1145/3763144},
abstract = {In many programming paradigms, some program entities are only valid within delimited regions of the   program, such as resources that might be automatically deallocated at the end of specific scopes. Outside their   live scopes, the corresponding entities are no longer valid – they are permanently invalidated. Sometimes, even   within the live scope of a resource, the use of that resource must become temporarily invalid, such as when   iterating over a mutable collection, as mutating the collection during iteration might lead to undefined behavior.   However, high-level general-purpose programming languages rarely allow this information to be reflected on   the type level. Most previously proposed solutions to this problem have relied on restricting either the aliasing   or the capture of variables, which can reduce the expressiveness of the language. In this paper, we propose a   higher-rank polymorphic type-and-effect system to statically track the permanent and temporary invalidation   of sensitive values and resources, without any aliasing or capture restrictions. We use Boolean-algebraic types   (unions, intersections, and negations) to precisely model the side effects of program terms and guarantee   they are invalidation-safe. Moreover, we present a complete and practical type inference algorithm, whereby   programmers only need to annotate the types of higher-rank and polymorphically-recursive functions. Our   system, nicknamed InvalML, has a wide range of applications where tracking invalidation is needed, including   stack-based and region-based memory management, iterator invalidation, data-race-free concurrency, mutable   state encapsulation, type-safe exception and effect handlers, and even scope-safe metaprogramming.},
journal = {Proc. ACM Program. Lang.},
month = oct,
articleno = {366},
numpages = {31},
keywords = {effect systems, higher-rank polymorphism, type inference}
}

/*

Higher-rank polymorphism and polymorphic recursion, which we need, are not amenable to full type inference (for which they are both undecidable in general [36, 41]).

However, traditional unification-based row polymorphism has severe limitations which are exacerbated in the context of effect systems [52] and notably sufefrs from the well-known poisoning problem [93]. ReML [24] adopts Tofte and Birkedal [85]’s region labels that are similar to a simple form of row polymorphism. Row polymorphism was originally preferred over subtyping to model extensible records [75, 77, 91], but more recent work showed that subtype inference could be made more tractable by adopting an algebraic approach [20, 21, 64, 71],

Since complete type inference for higher-rank systems is undecidable [69]
*/
