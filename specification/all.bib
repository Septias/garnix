@article{dolan2017algebraic,
  title={Algebraic Subtyping},
  author={Dolan, S.},
  isbn={9781780174150},
  series={BCS/CPHC distinguished dissertation award series},
  url={https://books.google.co.jp/books?id=cBJdswEACAAJ},
  year={2017},
  publisher={BCS Learning \& Development Limited}
}

@article{invalml,
author = {Gao, Cunyuan and Parreaux, Lionel},
title = {A Lightweight Type-and-Effect System for Invalidation Safety: Tracking Permanent and Temporary Invalidation with Constraint-Based Subtype Inference},
year = {2025},
issue_date = {October 2025},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {9},
number = {OOPSLA2},
url = {https://doi.org/10.1145/3763144},
doi = {10.1145/3763144},
abstract = {In many programming paradigms, some program entities are only valid within delimited regions of the   program, such as resources that might be automatically deallocated at the end of specific scopes. Outside their   live scopes, the corresponding entities are no longer valid – they are permanently invalidated. Sometimes, even   within the live scope of a resource, the use of that resource must become temporarily invalid, such as when   iterating over a mutable collection, as mutating the collection during iteration might lead to undefined behavior.   However, high-level general-purpose programming languages rarely allow this information to be reflected on   the type level. Most previously proposed solutions to this problem have relied on restricting either the aliasing   or the capture of variables, which can reduce the expressiveness of the language. In this paper, we propose a   higher-rank polymorphic type-and-effect system to statically track the permanent and temporary invalidation   of sensitive values and resources, without any aliasing or capture restrictions. We use Boolean-algebraic types   (unions, intersections, and negations) to precisely model the side effects of program terms and guarantee   they are invalidation-safe. Moreover, we present a complete and practical type inference algorithm, whereby   programmers only need to annotate the types of higher-rank and polymorphically-recursive functions. Our   system, nicknamed InvalML, has a wide range of applications where tracking invalidation is needed, including   stack-based and region-based memory management, iterator invalidation, data-race-free concurrency, mutable   state encapsulation, type-safe exception and effect handlers, and even scope-safe metaprogramming.},
journal = {Proc. ACM Program. Lang.},
month = oct,
articleno = {366},
numpages = {31},
keywords = {effect systems, higher-rank polymorphism, type inference}
}

@article{mlstruct,
author = {Parreaux, Lionel and Chau, Chun Yin},
title = {MLstruct: principal type inference in a Boolean algebra of structural types},
year = {2022},
issue_date = {October 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {OOPSLA2},
url = {https://doi.org/10.1145/3563304},
doi = {10.1145/3563304},
abstract = {Intersection and union types are becoming more popular by the day, entering the mainstream in programming languages like TypeScript and Scala 3. Yet, no language so far has managed to combine these powerful types with principal polymorphic type inference. We present a solution to this problem in MLstruct, a language with subtyped records, equirecursive types, first-class unions and intersections, class-based instance matching, and ML-style principal type inference. While MLstruct is mostly structurally typed, it contains a healthy sprinkle of nominality for classes, which gives it desirable semantics, enabling the expression of a powerful form of extensible variants that does not need row variables. Technically, we define the constructs of our language using conjunction, disjunction, and negation connectives, making sure they form a Boolean algebra, and we show that the addition of a few nonstandard but sound subtyping rules gives us enough structure to derive a sound and complete type inference algorithm. With this work, we hope to foster the development of better type inference for present and future programming languages with expressive subtyping systems.},
journal = {Proc. ACM Program. Lang.},
month = oct,
articleno = {141},
numpages = {30},
keywords = {union and intersection types, structural typing, principal type inference}
}

@article{mlsub_short,
author = {Dolan, Stephen and Mycroft, Alan},
title = {Polymorphism, subtyping, and type inference in MLsub},
year = {2017},
issue_date = {January 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/3093333.3009882},
doi = {10.1145/3093333.3009882},
abstract = {We present a type system combining subtyping and ML-style parametric polymorphism. Unlike previous work, our system supports type inference and has compact principal types. We demonstrate this system in the minimal language MLsub, which types a strict superset of core ML programs. This is made possible by keeping a strict separation between the types used to describe inputs and those used to describe outputs, and extending the classical unification algorithm to handle subtyping constraints between these input and output types. Principal types are kept compact by type simplification, which exploits deep connections between subtyping and the algebra of regular languages. An implementation is available online.},
journal = {SIGPLAN Not.},
month = {jan},
pages = {60–72},
numpages = {13},
keywords = {Type Inference, Subtyping, Polymorphism, Algebra}
}

@inproceedings{10.1145/3009837.3009882,
author = {Dolan, Stephen and Mycroft, Alan},
title = {Polymorphism, subtyping, and type inference in MLsub},
year = {2017},
isbn = {9781450346603},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3009837.3009882},
doi = {10.1145/3009837.3009882},
abstract = {We present a type system combining subtyping and ML-style parametric polymorphism. Unlike previous work, our system supports type inference and has compact principal types. We demonstrate this system in the minimal language MLsub, which types a strict superset of core ML programs. This is made possible by keeping a strict separation between the types used to describe inputs and those used to describe outputs, and extending the classical unification algorithm to handle subtyping constraints between these input and output types. Principal types are kept compact by type simplification, which exploits deep connections between subtyping and the algebra of regular languages. An implementation is available online.},
booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
pages = {60–72},
numpages = {13},
keywords = {Type Inference, Subtyping, Polymorphism, Algebra},
location = {Paris, France},
series = {POPL '17}
}

@Inbook{nixos,
author="Dieguez Castro, Jose",
title="NixOS",
bookTitle="Introducing Linux Distros",
year="2016",
publisher="Apress",
address="Berkeley, CA",
pages="301--327",
abstract="Thus Nix was created as part of academic research and NixOS was created as a proof of concept that Nix could be used to manage a whole Linux distro. Dolstra also would develop other tools like Hydra, which is a Nix-based continuous integration tool, and NixOps, which is a tool for provisioning and deploying NixOS machines.",
isbn="978-1-4842-1392-6",
doi="10.1007/978-1-4842-1392-6_14",
url="https://doi.org/10.1007/978-1-4842-1392-6_14"
}

@article{simplesub,
author = {Parreaux, Lionel},
title = {The simple essence of algebraic subtyping: principal type inference with subtyping made easy (functional pearl)},
year = {2020},
issue_date = {August 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {ICFP},
url = {https://doi.org/10.1145/3409006},
doi = {10.1145/3409006},
abstract = {MLsub extends traditional Hindley-Milner type inference with subtyping while preserving compact principal types, an exciting new development. However, its specification in terms of biunification is difficult to understand, relying on the new concepts of bisubstitution and polar types, and making use of advanced notions from abstract algebra. In this paper, we show that these are in fact not essential to understanding the mechanisms at play in MLsub. We propose an alternative algorithm called Simple-sub, which can be implemented efficiently in under 500 lines of code (including parsing, simplification, and pretty-printing), looks more familiar, and is easier to understand.  We present an experimental evaluation of Simple-sub against MLsub on a million randomly-generated well-scoped expressions, showing that the two systems agree. The mutable automaton-based implementation of MLsub is quite far from its algebraic specification, leaving a lot of space for errors; in fact, our evaluation uncovered several bugs in it. We sketch more straightforward soundness and completeness arguments for Simple-sub, based on a syntactic specification of the type system.  This paper is meant to be light in formalism, rich in insights, and easy to consume for prospective designers of new type systems and programming languages. In particular, no abstract algebra is inflicted on readers.},
journal = {Proc. ACM Program. Lang.},
month = {aug},
articleno = {124},
numpages = {28},
keywords = {type inference, subtyping, principal types}
}

@article{superF,
author = {Parreaux, Lionel and Boruch-Gruszecki, Aleksander and Fan, Andong and Chau, Chun Yin},
title = {When Subtyping Constraints Liberate: A Novel Type Inference Approach for First-Class Polymorphism},
year = {2024},
issue_date = {January 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {POPL},
url = {https://doi.org/10.1145/3632890},
doi = {10.1145/3632890},
abstract = {Type inference in the presence of first-class or “impredicative” second-order polymorphism \`{a} la System F has been an active research area for several decades, with original works dating back to the end of the 80s. Yet, until now many basic problems remain open, such as how to type check expressions like (λx.(x  123, x  True)) id reliably. We show that a type inference approach based on multi-bounded polymorphism, a form of implicit polymorphic subtyping with multiple lower and upper bounds, can help us resolve most of these problems in a uniquely simple and regular way. We define F≤, a declarative type system derived from the existing theory of implicit coercions by Cretin and R\'{e}my (LICS 2014), and we introduce SuperF, a novel algorithm to infer polymorphic multi-bounded F≤ types while checking user type annotations written in the syntax of System F. We use a recursion-avoiding heuristic to guarantee termination of type inference at the cost of rejecting some valid programs, which thankfully rarely triggers in practice. We show that SuperF is vastly more powerful than all first-class-polymorphic type inference systems proposed so far, significantly advancing the state of the art in type inference for general-purpose programming languages.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {48},
numpages = {33},
keywords = {type inference, first-class polymorphism, subtyping, constraint solving}
}

@article{max_lazy,
title = {Maximal Laziness: An Efficient Interpretation Technique for Purely Functional DSLs},
journal = {Electronic Notes in Theoretical Computer Science},
volume = {238},
number = {5},
pages = {81-99},
year = {2009},
note = {Proceedings of the 8th Workshop on Language Descriptions, Tools and Applications (LDTA 2008)},
issn = {1571-0661},
doi = {https://doi.org/10.1016/j.entcs.2009.09.042},
url = {https://www.sciencedirect.com/science/article/pii/S157106610900396X},
author = {Eelco Dolstra},
keywords = {Lazy functional language, maximallaziness, maximal sharing},
abstract = {In lazy functional languages, any variable is evaluated at most once. This paper proposes the notion of maximal laziness, in which syntactically equal terms are evaluated at most once: if two terms e1 and e2 arising during the evaluation of a program have the same abstract syntax representation, then only one will be evaluated, while the other will reuse the former's evaluation result. Maximal laziness can be implemented easily in interpreters for purely functional languages based on term rewriting systems that have the property of maximal sharing — if two terms are equal, they have the same address. It makes it easier to write interpreters, as techniques such as closure updating, which would otherwise be required for efficiency, are not needed. Instead, a straight-forward translation of call-by-name semantic rules yields a call-by-need interpreter, reducing the gap between the language specification and its implementation. Moreover, maximal laziness obviates the need for optimisations such as memoisation and let-floating.}
}

@inproceedings{dolstra_phd,
  title={The purely functional software deployment model},
  author={Eelco Dolstra},
  year={2006},
  url={https://api.semanticscholar.org/CorpusID:8511820}
}

@inproceedings{nixos_short,
author = {Dolstra, Eelco and L\"{o}h, Andres},
title = {NixOS: a purely functional Linux distribution},
year = {2008},
isbn = {9781595939197},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1411204.1411255},
doi = {10.1145/1411204.1411255},
abstract = {Existing package and system configuration management tools suffer from an imperative model, where system administration actions such as upgrading packages or changes to system configuration files are stateful: they destructively update the state of the system. This leads to many problems, such as the inability to roll back changes easily, to run multiple versions of a package side-by-side, to reproduce a configuration deterministically on another machine, or to reliably upgrade a system. In this paper we show that we can overcome these problems by moving to a purely functional system configuration model. This means that all static parts of a system (such as software packages, configuration files and system startup scripts) are built by pure functions and are immutable, stored in a way analogously to a heap in a purely function language. We have implemented this model in NixOS, a non-trivial Linux distribution that uses the Nix package manager to build the entire system configuration from a purely functional specification.},
booktitle = {Proceedings of the 13th ACM SIGPLAN International Conference on Functional Programming},
pages = {367–378},
numpages = {12},
keywords = {NixOS, nix, package management, purely functional deployment model, purely functional language, software deployment, system configuration management},
location = {Victoria, BC, Canada},
series = {ICFP '08}
}


@article{nixos_long,
title={NixOS: A purely functional Linux distribution},
volume={20},
DOI={10.1017/S0956796810000195},
number={5–6},
journal={Journal of Functional Programming},
author={DOLSTRA, EELCO and LÖH, ANDRES and PIERRON, NICOLAS},
year={2010},
pages={577–615}
}
